"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConfigForFunction = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const is_path_inside_1 = __importDefault(require("is-path-inside"));
const merge_options_1 = __importDefault(require("merge-options"));
const matching_js_1 = require("./utils/matching.js");
const getConfigForFunction = async ({ config, configFileDirectories, func, featureFlags, }) => {
    const fromConfig = getFromMainConfig({ config, func });
    // We try to read from a function config file if the function directory is
    // inside one of `configFileDirectories`.
    const shouldReadConfigFile = featureFlags.project_deploy_configuration_api_use_per_function_configuration_files &&
        (configFileDirectories === null || configFileDirectories === void 0 ? void 0 : configFileDirectories.some((directory) => (0, is_path_inside_1.default)(func.mainFile, directory)));
    if (!shouldReadConfigFile) {
        return fromConfig;
    }
    const fromFile = await getFromFile(func);
    return {
        ...fromConfig,
        ...fromFile,
    };
};
exports.getConfigForFunction = getConfigForFunction;
const getFromMainConfig = ({ config, func, }) => {
    if (!config) {
        return {};
    }
    // It's safe to mutate the array because it's local to this function.
    const matches = Object.keys(config)
        .filter((expression) => (0, matching_js_1.minimatch)(func.name, expression))
        .map((expression) => {
        const wildcardCount = [...expression].filter((char) => char === '*').length;
        // The weight increases with the number of hardcoded (i.e. non-wildcard)
        // characters â€” e.g. "netlify" has a higher weight than "net*". We do a
        // subtraction of 1 if there is at least one wildcard character, so that
        // "netlify" has a higher weight than "netlify*".
        const weight = expression.length - wildcardCount - (wildcardCount === 0 ? 0 : 1);
        return {
            expression,
            weight,
        };
    })
        .sort(({ weight: weightA }, { weight: weightB }) => weightA - weightB)
        .map(({ expression }) => config[expression]);
    return merge_options_1.default.apply({ concatArrays: true, ignoreUndefined: true }, matches);
};
const getFromFile = async (func) => {
    const filename = `${(0, path_1.basename)(func.mainFile, (0, path_1.extname)(func.mainFile))}.json`;
    const configFilePath = (0, path_1.join)((0, path_1.dirname)(func.mainFile), filename);
    try {
        const data = await fs_1.promises.readFile(configFilePath, 'utf8');
        const configFile = JSON.parse(data);
        if (configFile.version === 1) {
            return configFile.config;
        }
    }
    catch {
        // no-op
    }
    return {};
};
//# sourceMappingURL=config.js.map